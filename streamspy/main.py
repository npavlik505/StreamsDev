#! /usr/bin/python3
print("RUNNING PYTHON VERSION")

# libstreams is a python library that is generated by f2py build routines in
# the apptainer build pipeline. If you change anything in the fortran code, you
# must rebuild libstreams with f2py before the changes are reflected in the python 
# code
import libstreamsMin as streamsMin
import libstreamsMod as streamsMod
# we have to start MPI here before importing the mpi4py library
# otherwise, there will be an error in the streams code when they attempt to 
# initialize
print("ATTRIBUTES IN libstreams:", dir(streamsMin))
print("ATTRIBUTES IN libstreams:", dir(streamsMod))
streamsMin.wrap_startmpi()

from mpi4py import MPI
import json
import math
import importlib

#
# initialize some global variables
# we do this here since some modules after this will attempt to import global variables
# and if they have not been initialized it will error
#
import globals
globals.init()
from globals import rank, comm

import io_utils
import numpy as np
from config import Config
import utils
import jet_actuator

#
# Load in config, initialize
#

with open("/input/input.json", "r") as f:
    json_data = json.load(f)
    config = Config.from_json(json_data)

#
# allocate arrays so we dont need to reallocate in the solver loop
#

span_average = np.zeros([5, config.nx_mpi(), config.ny_mpi()], dtype=np.float64)
temp_field = np.zeros((config.nx_mpi(), config.ny_mpi(), config.nz_mpi()), dtype=np.float64)
dt_array = np.zeros(1)
amplitude_array = np.zeros(1)
time_array = np.zeros(1)
dissipation_rate_array = np.zeros(1)
energy_array = np.zeros(1)

#
# execute streams setup routines
#

def setup_solver():
    streamsMin.wrap_setup()
    streamsMin.wrap_init_solver()

setup_solver()

#
# define functions to access mod_streams variables
#

def get_w(size):
    arr = np.empty(size, dtype=np.float64)
    streamsMod.wrap_get_w(arr, size)
    return arr

def get_blowing_bc_slot_velocity(size):
    arr = np.empty(size, dtype=np.float64)
    streamsMod.wrap_get_blowing_bc_slot_velocity(arr, size)
    return arr

def get_x_start_slot():
    val = np.empty(1, dtype=np.int32)
    streamsMod.wrap_get_x_start_slot(val)
    return int(val[0])

def get_x_slice():
    arr = np.empty(config.grid.nx + 2 * config.grid.ng, dtype=np.float64)
    streamsMod.wrap_get_x(arr)
    return arr[config.x_start():config.x_end()]

def get_y_slice():
    arr = np.empty(config.grid.ny + 2 * config.grid.ng, dtype=np.float64)
    streamsMod.wrap_get_y(arr)
    return arr[config.y_start():config.y_end()]

def get_z_slice():
    arr = np.empty(config.grid.nz + 2 * config.grid.ng, dtype=np.float64)
    streamsMod.wrap_get_z(arr)
    return arr[config.z_start():config.z_end()]

def get_dtglobal():
    val = np.empty(1, dtype=np.float64)
    streamsMod.wrap_get_dtglobal(val)
    return float(val[0])

# initialize files

#
# Initialize datasets and HDF5 output files
#
flowfields = io_utils.IoFile("/distribute_save/flowfields.h5")
span_averages = io_utils.IoFile("/distribute_save/span_averages.h5")
trajectories = io_utils.IoFile("/distribute_save/trajectories.h5")
mesh_h5 = io_utils.IoFile("/distribute_save/mesh.h5")

grid_shape = [config.grid.nx, config.grid.ny, config.grid.nz]
span_average_shape = [config.grid.nx, config.grid.ny]

# 3D flowfield files
if not (config.temporal.full_flowfield_io_steps is None):
    flowfield_writes = int(math.ceil(config.temporal.num_iter / config.temporal.full_flowfield_io_steps))
else:
    flowfield_writes = 0
velocity_dset = io_utils.VectorField3D(flowfields, [5, *grid_shape], flowfield_writes, "velocity", rank)
flowfield_time_dset = io_utils.Scalar1D(flowfields, [1], flowfield_writes, "time", rank)

# span average files
numwrites = int(math.ceil(config.temporal.num_iter / config.temporal.span_average_io_steps))

# this is rho, u, v, w, E (already normalized from the rho u, rho v... values from streams)
span_average_dset = io_utils.VectorFieldXY2D(span_averages, [5, *span_average_shape], numwrites, "span_average", rank)
shear_stress_dset = io_utils.ScalarFieldX1D(span_averages, [config.grid.nx], numwrites, "shear_stress", rank)
span_average_time_dset = io_utils.Scalar0D(span_averages, [1], numwrites, "time", rank)
dissipation_rate_dset = io_utils.Scalar0D(span_averages, [1], numwrites, "dissipation_rate", rank)
energy_dset = io_utils.Scalar0D(span_averages, [1], numwrites, "energy", rank)

# trajectories files
dt_dset = io_utils.Scalar0D(trajectories, [1], config.temporal.num_iter, "dt", rank)
amplitude_dset = io_utils.Scalar0D(trajectories, [1], config.temporal.num_iter, "jet_amplitude", rank)

# mesh datasets
x_mesh_dset = io_utils.Scalar1DX(mesh_h5, [config.grid.nx], 1, "x_grid", rank)
y_mesh_dset = io_utils.Scalar1D(mesh_h5, [config.grid.ny], 1, "y_grid", rank)
z_mesh_dset = io_utils.Scalar1D(mesh_h5, [config.grid.nz], 1, "z_grid", rank)



# Since mod_streams definitions must individually wrapped. Below is "mod_streams workaround 1"
# x_mesh = streams.mod_streams.x[config.x_start():config.x_end()]
# y_mesh = streams.mod_streams.y[config.y_start():config.y_end()]
# z_mesh = streams.mod_streams.z[config.z_start():config.z_end()]

x_mesh = get_x_slice()
y_mesh = get_y_slice()
z_mesh = get_z_slice()
# End of "mod_streams workaround 1"

x_mesh_dset.write_array(x_mesh)
print("y_mesh.shape:", y_mesh.shape)
print("Expected shape:", config.grid.ny)
y_mesh_dset.write_array(y_mesh)
z_mesh_dset.write_array(z_mesh)

#
# Main solver loop, we start time stepping until we are done
#

actuator = jet_actuator.init_actuator(rank, config)

time = 0
for i in range(config.temporal.num_iter):

    amplitude = actuator.step_actuator(time)

    streamsMin.wrap_step_solver()

    time += streamsMod.dtglobal
    time_array[:] = time

    if (i % config.temporal.span_average_io_steps) == 0:
        utils.hprint("writing span average to output")
        streamsMin.wrap_copy_gpu_to_cpu()
        streams_data_slice = config.slice_flowfield_array(streams.mod_streams.w)
        utils.calculate_span_averages(config, span_average, temp_field, streams_data_slice)

        span_average_dset.write_array(span_average)

        # also write shear stress information
        streamsMin.wrap_tauw_calculate()
        shear_stress_dset.write_array(streams.mod_streams.tauw_x)

        # write the time at which this data was collected
        span_average_time_dset.write_array(time_array)

        # calculate dissipation rate on GPU and store the result
        streamsMin.wrap_dissipation_calculation()
        dissipation_rate_array[:] = streams.mod_streams.dissipation_rate
        dissipation_rate_dset.write_array(dissipation_rate_array)
        utils.hprint(f"dissipation is {dissipation_rate_array[0]}")

        # calculate energy on GPU and store the result
        streamsMin.wrap_energy_calculation()
        energy_array[:] = streamsMod.energy
        energy_dset.write_array(energy_array)

        utils.hprint(f"energy is {energy_array[0]}")

    # save dt information for every step
    dt_array[:] = streamsMod.dtglobal
    dt_dset.write_array(dt_array)

    # save amplitude at every step
    amplitude_array[:] = amplitude
    amplitude_dset.write_array(amplitude_array)

    if not (config.temporal.full_flowfield_io_steps is None):
        if (i % config.temporal.full_flowfield_io_steps) == 0:
            utils.hprint("writing flowfield")
            streamsMin.wrap_copy_gpu_to_cpu()
            velocity_dset.write_array(config.slice_flowfield_array(streamsMod.w))

            # write the time at which this data was collected
            flowfield_time_dset.write_array(time_array)


    if i == 5:
        print("reloading python module")
        streamsMin.wrap_finalize_solver()
        #streams.wrap_finalize()
        del streamsMin
        del streamsMod
        import libstreamsMin as streamsMin
        import libstreamsMod as streamsMod
        #importlib.reload(streams)
        #streams.wrap_startmpi()
        setup_solver()

#
# wrap up execution of solver
#

streamsMin.wrap_finalize_solver()

print("finalizing solver")
streamsMin.wrap_finalize()
